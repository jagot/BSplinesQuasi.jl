<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Theory · BSplinesQuasi</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script src="../assets/latex.js"></script></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.svg" alt="BSplinesQuasi logo"/></a><h1>BSplinesQuasi</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Theory</a><ul class="internal"><li><a class="toctext" href="#Definitions-1">Definitions</a></li><li><a class="toctext" href="#Knot-sets-1">Knot sets</a></li><li><a class="toctext" href="#de-Boor&#39;s-algorithm-1">de Boor&#39;s algorithm</a></li><li><a class="toctext" href="#Integrals-1">Integrals</a></li><li><a class="toctext" href="#Derivatives-1">Derivatives</a></li><li><a class="toctext" href="#Solving-equations-1">Solving equations</a></li></ul></li><li><span class="toctext">Usage</span><ul><li><a class="toctext" href="../usage/">Basis creation</a></li><li><a class="toctext" href="../knot_sets/">Knot sets</a></li><li><span class="toctext">Splines</span><ul><li><a class="toctext" href="../splines/">Spline creation &amp; evaluation</a></li><li><a class="toctext" href="../function_approximation/">Function approximation</a></li></ul></li><li><a class="toctext" href="../operators/">Approximating operators</a></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../differentiation/">Differentiating functions</a></li><li><a class="toctext" href="../odes/">Ordinary differential equations</a></li><li><a class="toctext" href="../eigenproblems/">Eigenproblems</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Theory</a></li></ul><a class="edit-page" href="https://github.com/jagot/BSplinesQuasi.jl/blob/master/docs/src/theory.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Theory</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Theory-1" href="#Theory-1">Theory</a></h1><p>The underlying equations for the definition and efficient evaluation of B-splines are introduced. Equations labelled (dB.A.ij) refer to equation (ij) in chapter A of</p><ul><li>Carl de Boor (2001). <em>A Practical Guide to Splines</em>. New York: Springer. ISBN: 978-0-387-95366-3.</li></ul><h2><a class="nav-anchor" id="Definitions-1" href="#Definitions-1">Definitions</a></h2><p>The <em>order</em> of the polynomial is designated <span>$k$</span>, equal to the degree + 1, i.e. a parabolic polynomial is of order 3.</p><p>The B-splines can be defined through the Cox–de Boor recursion relation: <span>$\begin{equation} \tag{dB.IX.14} \B{j}{k} \defd \omega_{jk}\B{j}{k-1} + (1-\omega_{j+1,k})\B{j+1}{k-1}, \end{equation}$</span> where <span>$\begin{equation} \tag{dB.IX.15} \omega_{jk}(x) \defd \frac{x-t_j}{t_{j+k-1}-t_j}, \end{equation}$</span> and <span>$\begin{equation} \tag{dB.IX.11} \B{r}{1}(x) = \begin{cases} 1, &amp; x\in [t_r,t_{r+1}),\\
0, &amp; \textrm{else},\\
\end{cases}\quad r\in[1,n_t-1]. \end{equation}$</span></p><p>Given a knot vector <span>$\vec{t}$</span> of length <span>$n_t$</span>, there are <span>$n_{tk}\defd n_t-k$</span> functions of order <span>$k$</span>. This implies that there is a highest order <span>$k$</span> a given knot set vector can support, i.e. <span>$k_{\textrm{max}} = n_t - 1$</span>.</p><h2><a class="nav-anchor" id="Knot-sets-1" href="#Knot-sets-1">Knot sets</a></h2><p>As seen above, the B-splines are completely defined by the knot set vector <span>$\vec{t}$</span>.</p><p>The knot set <span>$\vec{t}=\bmat{1&amp;2&amp;3&amp;4&amp;5&amp;6}$</span> gives rise to the following cardinal splines, of orders <span>$k=1..5$</span>: <img src="../figures/cardinal-splines.svg" alt="Cardinal splines"/></p><p>By increasing the <em>multiplicity</em> of some knots, the continuity of the splines can be controlled. E.g. the knot set <span>$\vec{t}=\bmat{0&amp;1&amp;1&amp;3&amp;4&amp;6&amp;6&amp;6}$</span>, will yield the following splines: <img src="../figures/discontinuous-splines.svg" alt="Discontinuous splines"/></p><p>Lastly, it is very common to pad the knot set such that the first and last knot have multiplicity <span>$k$</span>; this simplifies the implementation of boundary conditions when B-splines are used for solving differential equations: <img src="../figures/full-multiplicity-splines.svg" alt="Full multiplicity splines"/></p><h2><a class="nav-anchor" id="de-Boor&#39;s-algorithm-1" href="#de-Boor&#39;s-algorithm-1">de Boor&#39;s algorithm</a></h2><p>An efficient way of evaluating the B-splines is given by <a href="https://en.wikipedia.org/wiki/De_Boor%27s_algorithm">de Boor&#39;s algorithm</a>. The algorithm described in the Wikipedia article <a href="#footnote-1">[1]</a> assumes full multiplicity at the endpoints of the knot set, i.e. that the first and last points are repeated <span>$k$</span> times. In the description of the same algorithm, de Boor additionally assumes a strictly increasing knot set, i.e. <span>$t_{i+1}&gt;t_i$</span>, do avoid any divisions by zero. Since one of the goals for this package is maximum flexibility in choosing the knot set, a derivation of an only slightly more general version of de Boor&#39;s algorithm follows.</p><p>Given a knot set <span>$\vec{t}$</span> of length <span>$n_t$</span>, the spline <span>$f(x)$</span> is given by <span>$\begin{equation} \tag{dB.X.23⅓ \&amp; ⅔} \begin{aligned} f(x) &amp;= \sum_{r=1}^{n_t-k} \alpha_r \B{r}{k}(x)\\
&amp;= \sum_{r=1}^{n_t-k} \alpha_r\frac{x-t_r}{t_{r+k-1}-t_r}\B{r}{k-1}(x)+ \sum_{r=1}^{n_t-k} \alpha_r\frac{t_{r+k}-x}{t_{r+k}-t_{r+1}}\B{r+1}{k-1}(x)\\
&amp;= \sum_{r=1}^{n_t-k} \alpha_r\frac{x-t_r}{t_{r+k-1}-t_r}\B{r}{k-1}(x)+ \sum_{r=2}^{n_t-k+1} \alpha_{r-1}\frac{t_{r+k-1}-x}{t_{r+k-1}-t_{r}}\B{r}{k-1}(x)\\
&amp;= \frac{x-t_1}{t_k-t_1}\alpha_1\B{1}{k-1}(x) + \left[ \sum_{r=2}^{n_t-k} \frac{(x-t_r)\alpha_r+(t_{r+k-1}-x)\alpha_{r-1}}{t_{r+k-1}-t_r}\B{r}{k-1}(x) \right] + \frac{t_{n_t}-x}{t_{n_t}-t_{n_t-k+1}}\alpha_{n_t-k}\B{n_t-k+1}{k-1}(x)\\
&amp;= \sum_{i=1}^{n_t-k+1} \alpha_i^{[2]}(x) \B{i}{k-1}(x), \end{aligned} \end{equation}$</span> where <span>$\begin{equation} \tag{dB.X.24} \alpha_r^{[2]}(x) \defd \begin{cases} \displaystyle \frac{x-t_1}{t_k-t_1}\alpha_1, &amp; r=1,\\[2ex] \displaystyle \frac{(x-t_r)\alpha_r+(t_{r+k-1}-x)\alpha_{r-1}}{t_{r+k-1}-t_r}, &amp; r\in[2,n_t-k],\\[2ex] \displaystyle \frac{t_{n_t}-x}{t_{n_t}-t_{n_t-k+1}}\alpha_{n_t-k}, &amp; r = n_t - k + 1. \end{cases} \end{equation}$</span> We have thus reexpressed the spline function <span>$f(x)$</span> of order <span>$k$</span> as a linear combination of B-splines of order <span>$k-1$</span>. We can generalize this, to reexpress <span>$f(x)$</span> as a linear combination of B-splines of order <span>$k-j$</span>, with expansion coefficients <span>$\begin{equation} \label{eqn:dB.X.26} \tag{dB.X.26} \alpha_r^{[j+1]}(x) \defd \begin{cases} \displaystyle \frac{x-t_1}{t_{1+k-j}-t_1}\alpha_1^{[j]}(x), &amp; r=1,\\[2ex] \displaystyle \frac{(x-t_r)\alpha_r^{[j]}(x)+(t_{r+k-j}-x)\alpha_{r-1}^{[j]}(x)}{t_{r+k-j}-t_r}, &amp; r\in[2,n_t-k+j-1],\\[2ex] \displaystyle \frac{t_{n_t}-x}{t_{n_t}-t_{n_t-k+j}}\alpha_{n_t-k+j-1}^{[j]}(x), &amp; r = n_t - k + j. \end{cases} \end{equation}$</span></p><p>The difference between this derivation and those in the Wikipedia article and de Boor (2001), is that we here explicitly consider the limits of the sum imposed by the length of the knot set and the order <span>$k$</span>; this introduces the special cases for <span>$r=1,n_t-k+j$</span>.</p><p>An important philosophical difference between the Cox–de Boor recursion relation and de Boor&#39;s algorithm, is that whereas the former is a linear combination of basis functions evaluated at certain position <span>$x$</span>, the latter is linear combination of <em>intervals</em> (since the first-order functions <span>$\B{j}{1}$</span> are non-zero within one interval only, and they are mutual orthogonal), with <em>polynomial</em> expansion coefficients <span>$\alpha_{i}^{[k]}(x)$</span>. To evaluate the spline function <span>$f(x)$</span>, we first find the interval <span>$i$</span> which contains <span>$x$</span>. Even if the knot set is only non-decreasing, i.e. not strictly increasing, the interval containing <span>$x$</span> is uniquely defined, since there is only one for which <span>$t_i \leq x &lt; t_{i+1}$</span>; if the knot <span>$t_i$</span> has a multiplicity higher than unity, the additional intervals cannot contain <span>$x$</span>, since they are empty: <span>$t_{i-1}\leq x &lt; t_i = \varnothing$</span> if <span>$t_{i-1} = t_i$</span>. By finding the <em>last</em> <span>$i$</span>, for which <span>$t_i \leq x$</span>, we thus guarantee that no divisions by zero will occur.</p><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>NB that the Wikipedia article uses 0-based indexing, whereas de Boor and BSplinesQuasi.jl use 1-based indexing.</p></div><h2><a class="nav-anchor" id="Integrals-1" href="#Integrals-1">Integrals</a></h2><p>Since the B-splines are piecewise polynomials, they can be exactly integrated using <a href="https://en.wikipedia.org/wiki/Gaussian_quadrature">Gauß–Legendre quadrature</a>; an <span>$N$</span>-point quadrature can integrate a polynomial of degree <span>$2N-1$</span> exactly. We are usually interested in integrals on the form</p><div>\[\begin{equation}
\matrixel{\B{j_1}{k}}{\operator{A}}{\B{j_2}{k}}\equiv
\int\diff{x}
\conj{\B{j_1}{k}}(x)
\operator{A}
\B{j_2}{k}(x),
\end{equation}\]</div><p>where <span>$\operator{A}$</span> is some operator. Assuming that <span>$\operator{A}$</span> can be approximated by a polynomial of order <span>$k&#39;$</span>, we need an <span>$N$</span>-point quadrature, such that <span>$2N-1\geq 2(k-1)+(k&#39;-1)$</span>, e.g. for <span>$\operator{A}\sim x^2$</span>, we choose <span>$N=\ceil{\frac{2k+1}{2}}=k+1$</span>.</p><p>For every non-empty interval generated by the knot set, we setup a Gauß–Legendre quadrature, such that an integral is approximated as</p><div>\[\begin{equation}
\int\limits_a^b \diff{x}f(x)\approx
\frac{b-a}{2}\sum_{i=1}^n w_i
f\left(\frac{b-a}{2}x_i+\frac{a+b}{2}\right),
\end{equation}\]</div><p>within each interval.</p><p>If we again consider the knot set <span>$\vec{t}=\bmat{0&amp;1&amp;1&amp;3&amp;4&amp;6&amp;6&amp;6}$</span> and allow operators of maximal polynomial order <span>$k&#39;=3$</span>, we get the following distribution quadrature points:</p><p><img src="../figures/quadrature-points.svg" alt="Quadrature points"/></p><p>Note that no quadrature points were generated for the intervals <span>$[t_i,t_{i+1})$</span>, <span>$i=2,6,7$</span>, since those intervals are empty. Also note that the quadrature points are <em>interior</em>, i.e. the domain boundaries are not included. That can be useful for dealing with functions which are singular/undefined at the boundaries.</p><p>With the quadrature in place, it becomes very easy to compute the overlap matrix:</p><div>\[\begin{equation}
\mat{S}_{ij,k} \defd \braket{\B{i}{k}}{\B{j}{k}}
\approx \sum_l w_l \conj{\B{i}{k}}(x_l) \B{j}{k}(x_l).
\end{equation}\]</div><p>For the knot set above, we find</p><div>\[\mat{S} =
\bmat{0.6 &amp;       0.222222 &amp;   0.0444444 &amp;  0.0 &amp;        0.0\\
 0.222222 &amp;  0.466667 &amp;   0.307407 &amp;   0.0037037 &amp;  0.0\\
 0.0444444 &amp;  0.307407 &amp;   0.962963 &amp;   0.307407 &amp;   0.0444444\\
 0.0 &amp;       0.0037037 &amp;  0.307407 &amp;   0.466667 &amp;   0.222222\\
 0.0 &amp;       0.0 &amp;        0.0444444 &amp;  0.222222 &amp;   0.4},\]</div><p>from which we see that the individual B-splines <span>$\B{i}{k}$</span> are non-zero only on the interval <span>$[t_i,t_{i+k})$</span>, except for the last B-spline that is non-zero also at the end of the interval, <span>$[t_i,t_{i+k}]$</span>.</p><p>If we want to employ two B-spline sets of different orders, we must make sure they share the same knot set and quadrature points (and that the latter support the combined polynomial order).</p><h2><a class="nav-anchor" id="Derivatives-1" href="#Derivatives-1">Derivatives</a></h2><p>A property of B-splines is that the first derivative of a spline is given by</p><div>\[\begin{equation}
\tag{dB.X.12}
\partial
\sum_j \alpha_j\B{j}{k} =
(k-1)\sum_j
\frac{\alpha_j - \alpha_{j-1}}{t_{j+k-1}-t_j}\B{j}{k-1},
\end{equation}\]</div><p>and by extension</p><div>\[\begin{equation}
\tag{dB.X.15}
\partial^m
\sum_j \alpha_j\B{j}{k} =
\sum_j \alpha_j^{(m+1)}\B{j}{j-m},
\end{equation}\]</div><p>where</p><div>\[\begin{equation}
\label{eqn:dB.X.16}
\tag{dB.X.16}
\alpha_j^{(m+1)} \defd
\begin{cases}
\alpha_r, &amp; m = 0,\\[2ex]
\displaystyle
\frac{\alpha_r^{(m)} - \alpha_{r-1}^{(m)}}{(t_{r+k-1}-t_r)/(k-m)}, &amp; m &gt; 0.
\end{cases}
\end{equation}\]</div><p>Comparing with <a href="#de-Boor&#39;s-algorithm-1">de Boor&#39;s algorithm</a>, above, <span>$\eqref{eqn:dB.X.16}$</span> is very similar in structure to <span>$\eqref{eqn:dB.X.26}$</span>, which means for calculating the <span>$m$</span>th derivative, we can apply <span>$\eqref{eqn:dB.X.16}$</span> for <span>$j\in[1,m]$</span>, and then switch to <span>$\eqref{eqn:dB.X.26}$</span> for <span>$j\in[m+1,k-1]$</span>.</p><h2><a class="nav-anchor" id="Solving-equations-1" href="#Solving-equations-1">Solving equations</a></h2><p>For any equation of the form</p><div>\[\begin{equation}
\operator{L}f = g,
\end{equation}\]</div><p>where <span>$\operator{L}$</span> is a linear functional, we can solve the equation approximately by expanding <span>$f$</span> and <span>$g$</span> in terms of B-splines:</p><div>\[\begin{equation}
\begin{aligned}
f &amp;= \sum_j \ket{\B{j}{k}}f_j \defd B\vec{f},\\
g &amp;= \sum_j \ket{\B{j}{k}}g_j \defd B\vec{g},
\end{aligned}
\end{equation}\]</div><p>where</p><div>\[\begin{equation}
B \defd \bmat{\ket{\B{1}{k}} &amp; \ket{\B{2}{k}} &amp; \dots &amp; \ket{\B{n}{k}}}.
\end{equation}\]</div><p>The equation is now transformed to</p><div>\[\begin{equation}
\operator{L}B\vec{f} = B\vec{g}.
\end{equation}\]</div><p>The left-hand side is trivially in the space <span>$\space{P}_{t,k}$</span>, whereas is not necessary true for the right-hand side, i.e. the functional <span>$\operator{L}$</span> may take <span>$f$</span> out of the space. We can project the equation into the space <span>$\space{P}_{t,k}$</span> by left-multiplying by the projector <span>$BB^H$</span>:</p><div>\[\begin{equation}
\begin{aligned}
BB^H\operator{L}B\vec{f} &amp;= BB^HB\vec{g},\\
\iff
B\mat{L}\vec{f} &amp;= B\mat{S}\vec{g},
\end{aligned}
\end{equation}\]</div><p>where</p><div>\[\begin{aligned}
\mat{L} &amp;\defd B^H\operator{L}B,\\
\mat{S} &amp;\defd B^HB.
\end{aligned}\]</div><p>Since, although the B-splines are non-orthogonal, they are <em>linearly independent</em>, the equation has to hold for any <span>$\ket{\B{i}{k}}$</span>, and we get</p><div>\[\begin{equation}
\mat{L}\vec{f} = \mat{S}\vec{g}.
\end{equation}\]</div><p>If for instance, <span>$g=\lambda f$</span>, we get</p><div>\[\begin{equation}
(\mat{L}-\lambda\mat{S})\vec{f} = 0,
\end{equation}\]</div><p>which is a <em>generalized eigenvalue problem</em>, which can be solved using e.g. <a href="https://github.com/haampie/ArnoldiMethod.jl">ArnoldiMethod.jl</a>.</p><p>If instead we want to calculate a derivative of <span>$f$</span>, i.e. <span>$\operator{L}=\partial^m$</span>, we find the vector of expansion coefficients for <span>$g$</span> as</p><div>\[\begin{equation}
\vec{g} = \mat{S}^{-1}\mat{D}^{(m)}\vec{f},
\end{equation}\]</div><p>where <span>$\mat{D}^{(m)} \defd B^H\partial^mB$</span>, the elements of which are calculated according to <a href="#Derivatives-1">Derivatives</a>.</p><p>Finally, if we want to solve a boundary-value problem, the solution is given by</p><div>\[\begin{equation}
\vec{f} = \mat{L}^{-1}\mat{S}\vec{g}.
\end{equation}\]</div><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../usage/"><span class="direction">Next</span><span class="title">Basis creation</span></a></footer></article></body></html>
